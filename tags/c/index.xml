<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on 不足为外人道</title>
    <link>http://luobin.me/tags/c/</link>
    <description>Recent content in C on 不足为外人道</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 07 Jun 2014 17:50:24 +0800</lastBuildDate>
    <atom:link href="http://luobin.me/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C&#43;&#43;智能指针</title>
      <link>http://luobin.me/post/C&#43;&#43;%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 07 Jun 2014 17:50:24 +0800</pubDate>
      
      <guid>http://luobin.me/post/C&#43;&#43;%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>

&lt;p&gt;&amp;emsp;&amp;emsp;关于智能指针，C++11中废弃了原来的auto_ptr，引入了shared_ptr,unique_ptr,weak_ptr。在引入智能指针之前，我们使用原生指针(built-in or raw)来手动控制内存的操作和释放，稍有不慎常会发生各种内存泄露或者undefined行为，这点使用c/c++开发过项目的必然都深有体会。世间万事万物都有其两面性，我们享受直接内存操作的便利快感的同时，有时候难免要忍受调试各种稀奇古怪的内存bug的酸爽。下面将逐个剖析新的智能指针系列引入的这几种类型的背后实现机制以及对于开发工作会有那些帮助。&lt;/p&gt;

&lt;h4 id=&#34;shared-ptr:86125507f6e433adf8544745a5755250&#34;&gt;shared_ptr&lt;/h4&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;首先这三种类型都是STL中实现的，具体不同的编译器附带的STL中的实现会有差异(事实上差异还比较大)，但是我们使用的时候需要引用的同一个头文件名:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;memory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于本人的主要开发环境是OS X,对应的主力编译器是clang,clang默认由原来使用GNU的libstdc++到现在自己重新实现了一套c++标准库，叫libc++,所以这里不加特别说明的话，当介绍具体实现的时候，默认指的是libc++的实现。&lt;br /&gt;
&amp;emsp;&amp;emsp;shared_基本用法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;
using namespace std;

class X{
public:
    X()=default;
    X(int value)
            :data(value)
    {
        cout &amp;lt;&amp;lt;&amp;quot;constructor&amp;quot;&amp;lt;&amp;lt;endl;
    }
    ~X()
    {
        cout &amp;lt;&amp;lt;&amp;quot;destrucctor&amp;quot;&amp;lt;&amp;lt;endl;
    }
    int get_data() const
    {
        return  data;
    }

    friend ostream&amp;amp; operator &amp;lt;&amp;lt; (ostream &amp;amp;out, const X&amp;amp; x)
    {
        out &amp;lt;&amp;lt;x.get_data();
        return out;
    }

private:
    int data;
};
void f()
{
    shared_ptr&amp;lt;X&amp;gt; sp(new X(5)); //
    cout&amp;lt;&amp;lt;*sp&amp;lt;&amp;lt;endl; //the same use as raw point
    cout &amp;lt;&amp;lt;&amp;quot;data = &amp;quot;&amp;lt;&amp;lt;sp-&amp;gt;get_data()&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 1
    shared_ptr&amp;lt;X&amp;gt; sp1 = sp;
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 2
    sp.reset();
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 0 because sp is reseted
    shared_ptr&amp;lt;X&amp;gt; sp2 = sp1;
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp1.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 2
    sp = sp1;  // now can also assign to sp with a same(or convertible) type of shared_ptr
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 3
    sp = nullptr; //the same effect as reset
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; //shoud print use_cout = 0
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp1.use_count()&amp;lt;&amp;lt;endl; // should print use_cout = 2
}
int main()
{
    f();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行下测试程序验证输出结果正如如我们注释中所料：
&lt;img src=&#34;http://77g3g7.com1.z0.glb.clouddn.com/shared_ptr.png&#34; alt=&#34;&#34; /&gt;
仅仅介绍怎么用远不是在我们这篇文章的终极目标，下面让我们一层一层揭开智能指针的神秘面纱。从上面的例子我们已经可以看出，shared_ptr本质是一个模板类，这个模板类实例化的参数类型就是对应我们要“智能”管理对象类型(或者 convertible的类型)，讲起来还是蛮拗口的,举个栗子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Y:public X
{
private:
    float value;
};
...
shared_ptr&amp;lt;X&amp;gt; sfp(new Y()); //这么写也是合法的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说了这么多，shared_ptr的本质就是一个包含raw指针以及关于这个raw指针的全局引用信息的对象，通过在这个对象的destructor中修改raw指针的全局引用信息来控制raw指针的释放时机。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template&amp;lt;class _Tp&amp;gt;
class _LIBCPP_TYPE_VIS_ONLY shared_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type*      __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;
    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;
    template&amp;lt;class _Yp&amp;gt;
        explicit shared_ptr(_Yp* __p,
                            typename enable_if&amp;lt;is_convertible&amp;lt;_Yp*, element_type*&amp;gt;::value, __nat&amp;gt;::type = __nat());
     			...
    element_type* get() const _NOEXCEPT {return __ptr_;}
    _LIBCPP_INLINE_VISIBILITY
    typename add_lvalue_reference&amp;lt;element_type&amp;gt;::type operator*() const _NOEXCEPT
        {return *__ptr_;}
    _LIBCPP_INLINE_VISIBILITY
    element_type* operator-&amp;gt;() const _NOEXCEPT {return __ptr_;}
    _LIBCPP_INLINE_VISIBILITY
    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_-&amp;gt;use_count() : 0;}
    			...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码所示，&lt;code&gt;__ptr_&lt;/code&gt;即是我们说的raw指针，&lt;code&gt;__cntrl_&lt;/code&gt;就是那个控制raw指针的全局引用信息的对象指针，其中&lt;code&gt;__share_weak_count&lt;/code&gt;又是继承自一个叫&lt;code&gt;__shared_count&lt;/code&gt;的类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class _LIBCPP_TYPE_VIS __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    _LIBCPP_INLINE_VISIBILITY
    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:
    void __add_shared() _NOEXCEPT;
    void __add_weak() _NOEXCEPT;
    void __release_shared() _NOEXCEPT;
    void __release_weak() _NOEXCEPT;
    _LIBCPP_INLINE_VISIBILITY
    long use_count() const _NOEXCEPT {return __shared_count::use_count();}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们上个shared_ptr简单实用的例子中输出的use_count信息实际上完全是由这个&lt;code&gt;shared_count&lt;/code&gt;来控制的,即实际是下面的__shared_owers_这个变量的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class _LIBCPP_TYPE_VIS __shared_count
{
    __shared_count(const __shared_count&amp;amp;);
    __shared_count&amp;amp; operator=(const __shared_count&amp;amp;);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() _NOEXCEPT = 0;

public:
    _LIBCPP_INLINE_VISIBILITY
    explicit __shared_count(long __refs = 0) _NOEXCEPT
        : __shared_owners_(__refs) {}

    void __add_shared() _NOEXCEPT;
    bool __release_shared() _NOEXCEPT;
    _LIBCPP_INLINE_VISIBILITY
    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shared_ptr&amp;lt;X&amp;gt; sp(new X(5));&lt;/code&gt;搞懂懂这个语句背后发生了什么，可谓费了好大一番周折，学习了C++中一种叫SFINAE的技巧&amp;mdash;&amp;mdash;&lt;em&gt;匹配失败并不是一种错误(Substitution Failure Is Not An Error)&lt;/em&gt;.
首先我们要搞懂shared_ptr模板类中下面这个声明的意思:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template&amp;lt;class _Yp&amp;gt;
explicit shared_ptr(_Yp* __p,typename enable_if&amp;lt;is_convertible&amp;lt;_Yp*, element_type*&amp;gt;::value, __nat&amp;gt;::type = __nat());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SFINAE名字听上去很高大上，其实知道is_convertible和enable_if表示什么意思后也不是太难理解.从字面上理解is_convertible应该就是判断两个类型是否可以相互转换,其模板类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template&amp;lt; class From, class To &amp;gt;
struct is_convertible;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;typename enable_if&amp;lt;is_convertible&amp;lt;_Yp*, element_type*&amp;gt;::value, __nat&amp;gt;::type = __nat()&lt;/code&gt;这一语句实际上表示的意思是当is_convertible的value为true的时候生命一个带默认值的形参，即成功匹配后的构造函数类型应该是这样的
&lt;code&gt;shared_ptr(X *__p,__nat=__nat())&lt;/code&gt;,为了验证下我们的分析，将我们上面的测试函数f()稍微修改一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void f()
{
    shared_ptr&amp;lt;X&amp;gt; sp(new X(5),{1});  //这里我们指定一个实参取代__nat() 
    cout&amp;lt;&amp;lt;*sp&amp;lt;&amp;lt;endl; //the same use as raw point
    cout &amp;lt;&amp;lt;&amp;quot;data = &amp;quot;&amp;lt;&amp;lt;sp-&amp;gt;get_data()&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 1
    shared_ptr&amp;lt;X&amp;gt; sp1 = sp;
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 2
    sp.reset();
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 0 because sp is reseted
    shared_ptr&amp;lt;X&amp;gt; sp2 = sp1;
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp1.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 2
    sp = sp1;  // now can also assign to sp with a same(or convertible) type of shared_ptr
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; // should print use_count = 3
    sp = nullptr; //the same effect as reset
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp.use_count()&amp;lt;&amp;lt;endl; //shoud print use_cout = 0
    cout &amp;lt;&amp;lt;&amp;quot;use_count = &amp;quot; &amp;lt;&amp;lt;sp1.use_count()&amp;lt;&amp;lt;endl; // should print use_cout = 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行，输出相同的结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;luobin@luobinMini:shared_point$ clang++ -std=c++11 main.cpp 
luobin@luobinMini:shared_point$ ./a.out 
constructor
5
data = 5
use_count = 1
use_count = 2
use_count = 0
use_count = 2
use_count = 3
use_count = 0
use_count = 2
destrucctor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是shared_ptr这个构造函数的具体模板实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template&amp;lt;class _Tp&amp;gt;
template&amp;lt;class _Yp&amp;gt;
shared_ptr&amp;lt;_Tp&amp;gt;::shared_ptr(_Yp* __p,
                            typename enable_if&amp;lt;is_convertible&amp;lt;_Yp*, element_type*&amp;gt;::value, __nat&amp;gt;::type)
    : __ptr_(__p)
{
    unique_ptr&amp;lt;_Yp&amp;gt; __hold(__p);
    typedef __shared_ptr_pointer&amp;lt;_Yp*, default_delete&amp;lt;_Yp&amp;gt;, allocator&amp;lt;_Yp&amp;gt; &amp;gt; _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, default_delete&amp;lt;_Yp&amp;gt;(), allocator&amp;lt;_Yp&amp;gt;()); //__contrl_实际上是个指向个__shared_ptr_pointer类型
    __hold.release();
    __enable_weak_this(__p);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;__shared_ptr_pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair&amp;lt;__compressed_pair&amp;lt;_Tp, _Dp&amp;gt;, _Alloc&amp;gt; __data_;
public:
    _LIBCPP_INLINE_VISIBILITY
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        :  __data_(__compressed_pair&amp;lt;_Tp, _Dp&amp;gt;(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}

#ifndef _LIBCPP_NO_RTTI
    virtual const void* __get_deleter(const type_info&amp;amp;) const _NOEXCEPT;
#endif

private:
    virtual void __on_zero_shared() _NOEXCEPT;  //这个是负责最终delete掉所管理的raw指针
    virtual void __on_zero_shared_weak() _NOEXCEPT; //这个是处理weak引用，暂不细表
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其成员&lt;code&gt;__data_&lt;/code&gt;是个&lt;code&gt;__compressd_pair&lt;/code&gt;,其中first依旧是个&lt;code&gt;__compressed_pair&lt;/code&gt;,second是个_Alloc(//叫对象生成器?)。first.first是_Alloc生成对象的指针类型(我们的raw指针)，first.second是个&lt;code&gt;default_delete&lt;/code&gt;(叫对象销毁器?),这个才是关键。
形势逐渐明朗了，现在我们可以一窥shared_ptr如何控制raw指针的释放时机了，进入~shared_ptr():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template&amp;lt;class _Tp&amp;gt;
shared_ptr&amp;lt;_Tp&amp;gt;::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_-&amp;gt;__release_shared();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入&lt;code&gt;__shared_weak_count&lt;/code&gt; 的&lt;code&gt;__release_shared()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void
__shared_weak_count::__release_shared() _NOEXCEPT
{
    if (__shared_count::__release_shared())
        __release_weak();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里调用下&lt;code&gt;__shared_count::__release_shared()&lt;/code&gt;,true 的话继续处理&lt;code&gt;__release_weak()&lt;/code&gt;,进入&lt;code&gt;__shared_count::__release_shared()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;bool
__shared_count::__release_shared() _NOEXCEPT
{
    if (decrement(__shared_owners_) == -1) //表示这是raw指针的最后一个引用
    {
        __on_zero_shared();
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于&lt;code&gt;__on_zero_shared()&lt;/code&gt;是个虚函数,所以这里实际上调用的是&lt;code&gt;__shared_ptr_pointer&lt;/code&gt;中的实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;__shared_ptr_pointer&amp;lt;_Tp, _Dp, _Alloc&amp;gt;::__on_zero_shared() _NOEXCEPT
{
    __data_.first().second()(__data_.first().first()); //first.first就是我们的raw指针，这里被最终释放啦
    __data_.first().second().~_Dp(); //?这里是销毁器也要释放的意思吗，看着像default_delete的析构函数？
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有前面分析已知fisrt().second()是一个default_delete:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template &amp;lt;class _Tp&amp;gt;
struct _LIBCPP_TYPE_VIS_ONLY default_delete
{
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;
#else
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}
#endif
    template &amp;lt;class _Up&amp;gt;
        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete&amp;lt;_Up&amp;gt;&amp;amp;,
             typename enable_if&amp;lt;is_convertible&amp;lt;_Up*, _Tp*&amp;gt;::value&amp;gt;::type* = 0) _NOEXCEPT {}
    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT
        {
            static_assert(sizeof(_Tp) &amp;gt; 0, &amp;quot;default_delete can not delete incomplete type&amp;quot;);
            static_assert(!is_void&amp;lt;_Tp&amp;gt;::value, &amp;quot;default_delete can not delete incomplete type&amp;quot;);
            delete __ptr;
        }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内部重载了operator()，接收一个_Tp* __ptr参数，&lt;code&gt;__data_.first().second()(__data_.first().first());&lt;/code&gt;这句调用时传进的参数正是我们的raw指针。
关于shared_ptr的分析告一段落。&lt;/p&gt;

&lt;h4 id=&#34;weak-ptr:86125507f6e433adf8544745a5755250&#34;&gt;weak_ptr&lt;/h4&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;经过上面的分析，shared_ptr似乎可以满足我们大部分关于指针的应用场景，然而智能毕竟不是万能,还有一些shared_ptr干不了的活,熟悉ios开发的同学应该清楚，强大的ARC(Automatic Reference Counting)技术依然解决不好如下图所示的循环引用的问题,所以引入了weak指针，同理C++11中引入weak_ptr来解决这一类问题.
&lt;img src=&#34;http://77g3g7.com1.z0.glb.clouddn.com/weak_ptr.png&#34; alt=&#34;&#34; /&gt;
我们可以把上面的&lt;code&gt;class X&lt;/code&gt;,稍微修改验证下循环引用的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class X{
public:
    X()= default;
    X(int value)
            :data(value),sp_(nullptr)
    {
        cout &amp;lt;&amp;lt;&amp;quot;constructor&amp;quot;&amp;lt;&amp;lt;endl;
    }
    X(int value,shared_ptr&amp;lt;X&amp;gt; &amp;amp;sp)
    :data(value),sp_(sp)
    {
        cout &amp;lt;&amp;lt;&amp;quot;constructor&amp;quot;&amp;lt;&amp;lt;endl;
    }
    ~X()
    {
        cout &amp;lt;&amp;lt;&amp;quot;destructor&amp;quot;&amp;lt;&amp;lt;endl;
    }
    int get_data() const
    {
        return  data;
    }

    friend ostream&amp;amp; operator &amp;lt;&amp;lt; (ostream &amp;amp;out, const X&amp;amp; x)
    {
        out &amp;lt;&amp;lt;x.get_data();
        return out;
    }
    void set_sp(shared_ptr&amp;lt;X&amp;gt; &amp;amp;sp)
    {
        sp_ = sp;
    }

private:
    int data;
    shared_ptr&amp;lt;X&amp;gt;  sp_;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void g()
{
    shared_ptr&amp;lt;X&amp;gt; sp1(new X(1));
    shared_ptr&amp;lt;X&amp;gt; sp2(new X(2,sp1));
    shared_ptr&amp;lt;X&amp;gt; sp3(new X(3,sp2));
    sp1-&amp;gt;set_sp(sp3);
}

int main()
{
    //f();
    g();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行编译一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;luobin@luobinMini:shared_point$ clang++ -std=c++11 main.cpp 
luobin@luobinMini:shared_point$ ./a.out 
constructor
constructor
constructor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实证明我们new出来的3个对象在g()退出后并没有被释放，而我们又失去了对其的控制，所以造成了内存泄露。
我们将成员&lt;code&gt;sp_&lt;/code&gt;改成weak_ptr,另外由于weak_ptr不能用nullptr构造,所以还要修改下第二个构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;    X(int value)
            :data(value)
    {
        cout &amp;lt;&amp;lt;&amp;quot;constructor&amp;quot;&amp;lt;&amp;lt;endl;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续执行相同的测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;luobin@luobinMini:shared_point$ clang++ -std=c++11 main.cpp 
luobin@luobinMini:shared_point$ ./a.out 
constructor
constructor
constructor
destructor
destructor
destructor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;perfect,完美解决环形引用的问题。
有了前面的分析基础，我们看下weak_ptr的模板类的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template&amp;lt;class _Tp&amp;gt;
class _LIBCPP_TYPE_VIS_ONLY weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type*        __ptr_;
    __shared_weak_count* __cntrl_;

public:
    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;
    template&amp;lt;class _Yp&amp;gt; weak_ptr(shared_ptr&amp;lt;_Yp&amp;gt; const&amp;amp; __r,
                   typename enable_if&amp;lt;is_convertible&amp;lt;_Yp*, _Tp*&amp;gt;::value, __nat*&amp;gt;::type = 0)
                        _NOEXCEPT;
    weak_ptr(weak_ptr const&amp;amp; __r) _NOEXCEPT;
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结构大同小异，甚至&lt;code&gt;__cntrl_&lt;/code&gt;都是相同的&lt;code&gt;__shared_weak_cout&lt;/code&gt;类型。&lt;/p&gt;

&lt;h4 id=&#34;unique-ptr:86125507f6e433adf8544745a5755250&#34;&gt;unique_ptr&lt;/h4&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;关于unique_ptr,从名字看，强调的是unique,表示的是全局只能有一个unique_ptr对象对raw指针拥有控制权。在一些适应的场景下比shared_ptr更高效一些，因为，&lt;code&gt;shared_ptr&lt;/code&gt;要通过一个&lt;code&gt;__cntrl_&lt;/code&gt;控制引用计数决定raw指针的施放时机，而&lt;code&gt;unique_ptr&lt;/code&gt;只需要维护一个&lt;code&gt;__ptr_&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template &amp;lt;class _Tp, class _Dp = default_delete&amp;lt;_Tp&amp;gt; &amp;gt;
class _LIBCPP_TYPE_VIS_ONLY unique_ptr
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type&amp;lt;_Tp, deleter_type&amp;gt;::type pointer;
private:
    __compressed_pair&amp;lt;pointer, deleter_type&amp;gt; __ptr_;

#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    unique_ptr(unique_ptr&amp;amp;);
    template &amp;lt;class _Up, class _Ep&amp;gt;
        unique_ptr(unique_ptr&amp;lt;_Up, _Ep&amp;gt;&amp;amp;);
    unique_ptr&amp;amp; operator=(unique_ptr&amp;amp;);
    template &amp;lt;class _Up, class _Ep&amp;gt;
        unique_ptr&amp;amp; operator=(unique_ptr&amp;lt;_Up, _Ep&amp;gt;&amp;amp;);
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt; 通过delete 掉copy constructor和 copy assignment operators来确保一个&lt;code&gt;unique_ptr&lt;/code&gt;对象对raw指针的唯一控制权。但是通过&lt;code&gt;std::move&lt;/code&gt;可以进行控制权之间的转移，所以使用&lt;code&gt;unique_ptr&lt;/code&gt;谨记一点即可：控制权只能转移，不能复制。&lt;/p&gt;

&lt;h4 id=&#34;总结:86125507f6e433adf8544745a5755250&#34;&gt;总结&lt;/h4&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;使用智能指针可以很大程度上将精力从繁琐的控制指针生命周期的工作中释放出来，这是C++作为一个没有GC的语言在开发效率上的一大进步。但是使用过程中要牢记，要么全部使用raw指针，要么交由智能指针全权负责，换句话说就是：要么裸奔，要么全副武装，切勿混搭。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;右值引用</title>
      <link>http://luobin.me/post/C&#43;&#43;%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</link>
      <pubDate>Fri, 21 Mar 2014 16:20:01 +0800</pubDate>
      
      <guid>http://luobin.me/post/C&#43;&#43;%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</guid>
      <description>

&lt;h3 id=&#34;value-category:6ca8daf46bf6dcff722d48a42c410183&#34;&gt;value category&lt;/h3&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;左值/右值是沿用c语言中的叫法，直观上理解就是分别出现在赋值表达式左右。c++标准中关于左值和右值的描述如下:
&amp;gt;An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression)designates a function or an object. [ Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example, the result of calling a function whose return type is an lvalue reference is an lvalue. — end example ]&lt;/p&gt;

&lt;p&gt;另外还有一种更加直观的描述(判断)：An lvalue (&amp;ldquo;left value&amp;rdquo;) expression is an expression that has identity and cannot be moved from.&amp;ndash;&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/value_category&#34;&gt;cpprefrence&lt;/a&gt;&lt;br /&gt;
以下是几种左值表达式的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a=b
++a,--a
std::cin,std::endl
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment expression) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated with an object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同理cppreference中关于右值表达式的描述:&amp;ldquo;An rvalue (&amp;ldquo;right value&amp;rdquo;) expression is an expression that is either a prvalue or an xvalue. It can be moved from. It may or may not have identity.&amp;rdquo;
几种右值例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;42 //常量
a++,a--
a+b,a&amp;amp;b
&amp;amp;a
std::move(x)
[](int x){return x*x} //lambda表达式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里提到的xvalue是新的标准中(c++11) 新增加的value category,另外还有glvalue(general lvalue),prvalue(pure rvalue)。glvalue只是个混合概念，由rvalue和xvalue构成；pvalue在标准中的描述为：&lt;br /&gt;
&amp;gt;A prvalue (“pure” rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is also a prvalue.
可以这样理解，rvalue里不是xvalue的就是pvalue。cppreference中给的描述是：&amp;rdquo;A prvalue (&amp;ldquo;pure rvalue&amp;rdquo;) expression is an expression that does not have identity and can be moved from.&amp;rdquo;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An xvalue (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). Certain kinds of expressions involving rvalue references (8.3.2) yield xvalues. [ Example: The result of calling a function whose return type is an rvalue reference to an object type is an xvalue (5.2.2). — end example ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以理解为，xvalue是rvalue的一种特例。关于xvalue最有代表性的例子是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a.m //其中a是rvalue，m是其非静态非引用成员
std::move(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以查看STL中move的实现:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;class _Tp&amp;gt;
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
typename remove_reference&amp;lt;_Tp&amp;gt;::type&amp;amp;&amp;amp;
move(_Tp&amp;amp;&amp;amp; __t) _NOEXCEPT
{
    typedef typename remove_reference&amp;lt;_Tp&amp;gt;::type _Up;
    return static_cast&amp;lt;_Up&amp;amp;&amp;amp;&amp;gt;(__t);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其返回值类型正式右值引用(rvalue reference)，正式标准中举的Example 类型。
&lt;img src=&#34;http://77g3g7.com1.z0.glb.clouddn.com/valueCategory.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;rvalue-reference:6ca8daf46bf6dcff722d48a42c410183&#34;&gt;rvalue reference&lt;/h3&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;好了关于c++的value category背景介绍就到这里，现在开始进入主题 rvalue reference。关于引用我们应该都很熟悉了，教材中都说了，引用是变量的别名&lt;code&gt;C++ references allow you to create a new name for an existing object.&lt;/code&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int var=42;
int&amp;amp; ref=var;
ref=99;
cout&amp;lt;&amp;lt;&amp;quot;var=&amp;quot;&amp;lt;&amp;lt;var&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们会的到输出：var=99;但是如果我们像下面这样写，编译器就不干了。因为传统的&amp;amp;引用是针对左值的，&lt;code&gt;Lvalue references can only be bound to lvalues&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int &amp;amp;ref=42;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是为了解决一些函数调用的传参问题，C++允许这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int const&amp;amp;=42；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这实际上是标准中的一个例外，在引入rvalue reference之前，标准中允许你给一个接受引用参数的函数传递临时变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void print(std::string const&amp;amp; s); 
print(&amp;quot;hello&amp;quot;);// Create temporary std::string object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c++11中引入&amp;amp;&amp;amp;符号，用于标示右值引用,并严格区分左右值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int&amp;amp;&amp;amp; i=42;
int j=42; 
int&amp;amp;&amp;amp; k=j; //error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就可以重写上面的printf函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void print(std::string const&amp;amp; s);
void print(std::string const&amp;amp;&amp;amp; s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们再调用:&lt;code&gt;print(&amp;quot;hello&amp;quot;);&lt;/code&gt;会调用第二个函数的实现。这正是C++11中实现move constructor 和 move assignment operator的基础。&lt;/p&gt;

&lt;h3 id=&#34;move-semantics:6ca8daf46bf6dcff722d48a42c410183&#34;&gt;move semantics&lt;/h3&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;考虑这样一种情况，实现一个函数，接受一个std:vector&lt;int&gt;参数，函数内部需要对这个传入vector进行修改和处理，但是要保证不能影响到原vector,以前我们可以这样实现：
    void process_copy(std::vector&lt;int&gt; const &amp;amp; vec)
    {
        std::vector&lt;int&gt; n_vec(vec);
        n_vec.push_back(40);
        &amp;hellip;
    }
对于这种实现，我们既可以传入lvalue实参，也可以传入rvalue实参（参见前文），但是不可避免的我们在内部处理的时候都需要对实参进行一份拷贝，尽管有时候实参只是个用完就会结束生命周期的临时变量。很容易设想，如果我们能够区分传入的是个rvalue，我们只是&lt;code&gt;move&lt;/code&gt;它的内容而不是对它进行拷贝，这对于占用存储空间很大的结构，会有非常理想的节省时间和存储空间的优化效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void process_copy(std::vector&amp;lt;int&amp;gt;&amp;amp;&amp;amp; vec)
{
    vec.push_back(40);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，关于move semantics最终要的应用就是 move constructor 和 move assignment operator&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class X{
public:
    X()
        :data(new char[10000])
    {
    print_tips(&amp;quot;default constructor&amp;quot;);
    }
~X()
{
    delete [] data;
    print_tips(&amp;quot;destructors&amp;quot;);
}
X(X&amp;amp; other)
        :data(new char[10000])
{
    std::copy(other.data,other.data+10000,data);
    print_tips(&amp;quot;copy constructor&amp;quot;);
}
X(X&amp;amp;&amp;amp; other)
        :data(other.data)
{
    other.data = nullptr;
    print_tips(&amp;quot;move constructor&amp;quot;);
}
X&amp;amp; operator=(const X&amp;amp; other)
{
    data = new char[10000];
    std::copy(other.data,other.data+10000,data);
    print_tips(&amp;quot;copy assignment constructor&amp;quot;);
    return *this;
}
X&amp;amp; operator=(X&amp;amp;&amp;amp; other)
{
    data = other.data;
    other.data = nullptr;
    print_tips(&amp;quot;move assignment constructor&amp;quot;);
    return *this;
}
private:
    char *data;
    void  print_tips(std::string const&amp;amp; str)
    {
        cout &amp;lt;&amp;lt;&amp;quot;in &amp;quot;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;endl;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以测试下不同情况下的函数调用情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X x1;
X x2(x1),x3(std::move(x1));
x2 = x3;
x2 = std::move(x3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以预见的是的顺序是(忽略default constructor 和 destructor)：copy constructor，move constructor，copy assignment operator，move assignment operator。执行这段代码验证下输出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://77g3g7.com1.z0.glb.clouddn.com/rvalueReference.png&#34; alt=&#34;rvalueReference&#34; title=&#34;rvalueReference&#34; /&gt;&lt;/p&gt;

&lt;p&gt;和std::move(x)等效的一种写法是 static_cast&lt;X&amp;&amp;&gt;(x),如果你明确知道一个lvalue x不会再用了，想把它的内容move过来，move和static_caset可以助你将其变成左值然后实现move semantic操作。
&amp;emsp;&amp;emsp;另外有一点要注意的事，对于函数的右值引用参数，可以将其bind to一个右值，但是在函数内部，其是被当做lvalue对待的，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void do_stuff(X&amp;amp;&amp;amp; x)
{
    X a(x);               //call copy constructor
    X b(std::move(x));    // call move constructor
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;好了，关于rvalue reference的相关总结暂时告一段落，其他相关内容遇到具体问题再做补充。最近在看C++ concurrency，Thread Library才是关于 move reference使用的重灾区，以后再表。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43;学习资源</title>
      <link>http://luobin.me/post/c&#43;&#43;%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</link>
      <pubDate>Sun, 09 Mar 2014 21:52:05 +0800</pubDate>
      
      <guid>http://luobin.me/post/c&#43;&#43;%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3?sortby=0&amp;amp;maxresults=15&amp;amp;order=desc&amp;amp;lang=en&#34;&gt;IBM C/C++ Cafe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq&#34;&gt;C++ FAQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.stroustrup.com/C++11FAQ.html&#34;&gt;C++11FAQ by Bjarne Stroustrup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/&#34;&gt;latest C++ standards drafts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.umich.edu/~eecs381/handouts/C++11_smart_ptrs.pdf&#34;&gt;C++11’s Smart Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms&#34;&gt;More C++ Idioms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.umich.edu/~eecs381/&#34;&gt;University of Michigan&amp;rsquo;s EECS 381 - Object-Oriented and Advanced Programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wuye9036/CppTemplateTutorial&#34;&gt;CppTemplateTutorial-空明流转作品&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.opensource.apple.com/source/libcpp/&#34;&gt;apple libcpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/&#34;&gt;isocpp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;blogs:e2038cc77dcd4378caf4476464aa8303&#34;&gt;Blogs&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://solarianprogrammer.com/&#34;&gt;Solarian Programmer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;graphic:e2038cc77dcd4378caf4476464aa8303&#34;&gt;Graphic&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ssloy/tinyrenderer/wiki&#34;&gt;How OpenGL works:soft render&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;network:e2038cc77dcd4378caf4476464aa8303&#34;&gt;Network&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudwu/skynet&#34;&gt;skynet&amp;ndash;A lightweight online game framework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kegel.com/c10k.html&#34;&gt;The C10K problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.wangafu.net/~nickm/libevent-book/&#34;&gt;Fast portable non-blocking network programming with Libevent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/&#34;&gt;cppreference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;特殊成员函数总结</title>
      <link>http://luobin.me/post/C&#43;&#43;%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 25 Aug 2013 09:48:23 +0800</pubDate>
      
      <guid>http://luobin.me/post/C&#43;&#43;%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;所谓特殊成员函数，按照c++11的标准描述：
&amp;gt;The default constructor, copy constructor and copy assignment operator , move constructor and move assignment operator , and destructor are special member functions. [Note: The implementation will implicitly declare these member functions for some class types when the program does not explicitly declare them. The implementation will implicitly define them if they are odr-used.
总结下就是：
.   Default constructors  //默认构造函数
.   Destructors           //析构函数
.   Copy constructors     //拷贝构造函数
.   Copy assignment operators //拷贝赋值操作
.   Move constructors     // move 构造函数
.   Move assignment operators  //move 复制操作&lt;/p&gt;

&lt;p&gt;根据标准中的描述，对于特殊成员函数，如果程序中没有明确的声明，编译器实现会进行隐式的声明，而且符合odr规则，也会提供一份隐式的实现。（odr&amp;ndash;One Definition Rule）。这里我们举个例子验证下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//这六个成员函数我们一个都没有显式的声明和定义
class X{
private:
    int data;
};
int main()
{
    X x1;  //但是我们却可以通过默认构造函数生成一个对象
    cout &amp;lt;&amp;lt;&amp;quot;x1.data=&amp;quot;&amp;lt;&amp;lt;x1.get_data()&amp;lt;&amp;lt;endl;
    X x2 = x1; //通过拷贝构造函数生成新的对象（对的，这种情况并不是调的assignment，后面会有演示）
    cout &amp;lt;&amp;lt;&amp;quot;x2.data=&amp;quot;&amp;lt;&amp;lt;x2.get_data()&amp;lt;&amp;lt;endl;
    X x3;
    cout &amp;lt;&amp;lt;&amp;quot;x3.data=&amp;quot;&amp;lt;&amp;lt;x3.get_data()&amp;lt;&amp;lt;endl;
    X3 = x1; //这才是assignment 操作
    cout &amp;lt;&amp;lt;&amp;quot;x3.data=&amp;quot;&amp;lt;&amp;lt;x3.get_data()&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;img src=&#34;http://77g3g7.com1.z0.glb.clouddn.com/special_member_function_1.png&#34; alt=&#34;&#34; /&gt;
正如我们所料，第1、2、4行输出的data值相等。说明隐式实现的拷贝构造和赋值操作会对data的值进行拷贝。&lt;br /&gt;
&amp;emsp;&amp;emsp;利用这一特性方便我们编程的同时，有些时候也会带来一些问题，最简单的，比如有时候我们想禁止对X类型的对象进行进行拷贝，赋值。语言层面就没有提供这样的支持，直到c++11引入了delete关键字。我们可以这样修改上面的class X:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class X{
public:
   //这里有个坑待填，好像是构造函数只要显示的写了一个，不论有没有delete，
   //默认构造函数不能再implicitly,否则会报错（至少我mac下用clang编译报错了）
    X()
    :data(random())
    {}
    X(const X&amp;amp;) = delete;
    X&amp;amp; operator = (const X&amp;amp;) = delete;
private:
    int data;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时我们再编译上面那段相同的测试代码，有两个编译错误：
&lt;img src=&#34;http://77g3g7.com1.z0.glb.clouddn.com/special_member_function_error.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;与delete对应的一个关键字是default,假如上面的class X，我们不想手写default constructor：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class X{
public:
    X() = default;
    X(const X&amp;amp;) = default;
    X&amp;amp; operator = (const X&amp;amp;) = default;
public:
    int get_data() const
    {
        return data;
    }
private:
    int data;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;另外，这些special member function 同样遵守c++的access rules，标准中的原话是这样说的：
&amp;gt;Special member functions obey the usual access rules (Clause 11). [Example: declaring a constructor protected ensures that only derived classes and friends can create objects using it. — end example ]&lt;/p&gt;

&lt;p&gt;如果我们灵活运用public、protect、private 等access rules，可以实现，满足各种特殊需求，比如常用的所谓单例模式，强制把各种可能构造出对象的相关的成员函数声明为private，仅提供一个static 成员函数用于获取/生成这个单例对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Singleton  
{
    public:
        static Singleton&amp;amp; Instance()
        {
        static Singleton instance；
        return instance；
        }
    private:
        Singleton()；
        ~Singleton()；
        Singleton(const Singleton&amp;amp;);
        Singleton&amp;amp; operator=(const Singleton&amp;amp;);
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>